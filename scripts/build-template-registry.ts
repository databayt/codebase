import { execFile } from "child_process"
import { existsSync, promises as fs } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import { z } from "zod"
import { Project, SyntaxKind } from "ts-morph"

// Import registry schema and templates
import { registrySchema } from "../src/components/root/template/registry"
import { templates } from "../src/components/root/template/registry-templates"

// Style configuration
const STYLES = [
  { name: "default", label: "Default" },
  // Add more styles as needed
]

type Style = (typeof STYLES)[number]

async function processFileContent(filePath: string): Promise<string> {
  try {
    // Read the file content
    const content = await fs.readFile(filePath, "utf-8")

    // Use ts-morph to process the file
    const project = new Project({
      compilerOptions: {
        jsx: 2, // JsxEmit.React
        target: 99, // ESNext
        module: 99, // ESNext
      },
    })

    const sourceFile = project.createSourceFile("temp.tsx", content, {
      overwrite: true,
    })

    // Remove "use client" directive if present
    const firstStatement = sourceFile.getStatements()[0]
    if (
      firstStatement &&
      firstStatement.getKind() === SyntaxKind.ExpressionStatement &&
      firstStatement.getText() === '"use client"'
    ) {
      firstStatement.remove()
    }

    // Fix import paths - remove @/ and replace with relative paths
    sourceFile.getImportDeclarations().forEach((importDecl) => {
      const moduleSpecifier = importDecl.getModuleSpecifierValue()

      // Convert @/components/ui/* to @/components/ui/*
      if (moduleSpecifier.startsWith("@/components/ui/")) {
        // Keep as is for UI components
        return
      }

      // Convert @/lib/* to relative paths
      if (moduleSpecifier.startsWith("@/lib/")) {
        importDecl.setModuleSpecifier(moduleSpecifier.replace("@/lib/", "@/lib/"))
      }

      // Convert @/hooks/* to relative paths
      if (moduleSpecifier.startsWith("@/hooks/")) {
        importDecl.setModuleSpecifier(moduleSpecifier.replace("@/hooks/", "@/hooks/"))
      }
    })

    return sourceFile.getText()
  } catch (error) {
    console.error(`Error processing file ${filePath}:`, error)
    return ""
  }
}

async function buildRegistryIndex(styles: Style[]) {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-template-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {`

  for (const style of styles) {
    // Create a registry object
    const registry = {
      name: style.name,
      items: templates,
    }

    // Validate the registry schema
    const parseResult = registrySchema.safeParse(registry)
    if (!parseResult.success) {
      console.error(`‚ùå Registry validation failed for ${style.name}:`)
      console.error(parseResult.error.format())
      throw new Error(`Invalid registry schema for ${style.name}`)
    }

    const validatedRegistry = parseResult.data

    index += `
  "${style.name}": {`

    for (const item of validatedRegistry.items) {
      const files =
        item.files?.map((file) => ({
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? item.type : file.type,
          target: typeof file === "string" ? undefined : file.target,
        })) ?? []

      if (files.length === 0) {
        continue
      }

      const componentPath = item.files?.[0]?.path
        ? `@/registry/${style.name}/${item.files[0].path}`
        : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${files.map((file) => {
        const filePath = `registry/${style.name}/${file.path}`
        return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        try {
          const mod = await import("${componentPath}")
          return { default: mod.default || mod[Object.keys(mod)[0]] }
        } catch (error) {
          console.error("Error loading component:", error)
          return { default: () => null }
        }
      })`
          : "null"
      },
      categories: ${JSON.stringify(item.categories)},
      meta: ${JSON.stringify(item.meta || {})},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  console.log(
    `#Ô∏è‚É£  Built multi-style index with ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`
  )

  // Create the __registry__ directory if it doesn't exist
  const registryDir = path.join(process.cwd(), "__registry__")
  await fs.mkdir(registryDir, { recursive: true })

  // Write unified index
  const indexPath = path.join(registryDir, "index.tsx")
  rimraf.sync(indexPath)
  await fs.writeFile(indexPath, index)

  console.log(`‚úÖ Written registry index to ${indexPath}`)
}

async function buildTemplateJsonFiles(styleName: string) {
  // Create a registry object
  const registry = {
    name: styleName,
    items: templates,
  }

  // Validate the registry schema
  const parseResult = registrySchema.safeParse(registry)
  if (!parseResult.success) {
    console.error(`‚ùå Registry validation failed for ${styleName}:`)
    console.error(parseResult.error.format())
    throw new Error(`Invalid registry schema for ${styleName}`)
  }

  const validatedRegistry = parseResult.data

  // Create the output directory
  const outputDir = path.join(process.cwd(), "public/r/templates", styleName)
  await fs.mkdir(outputDir, { recursive: true })

  // Process each template item and create individual JSON files
  for (const item of validatedRegistry.items) {
    try {
      // Process files and read their content
      const processedFiles = []

      if (item.files) {
        for (const file of item.files) {
          const filePath = typeof file === "string" ? file : file.path
          const fileType = typeof file === "string" ? item.type : (file.type || item.type)
          const fileTarget = typeof file === "string" ? undefined : file.target

          // Try to read the actual file content
          let content = ""
          const actualPath = path.join(process.cwd(), "src/components/root", filePath)

          if (existsSync(actualPath)) {
            content = await processFileContent(actualPath)
          }

          processedFiles.push({
            path: `registry/${styleName}/${filePath}`,
            type: fileType,
            target: fileTarget,
            content: content,
          })
        }
      }

      // Create the template JSON object
      const templateJson = {
        name: item.name,
        type: item.type,
        description: item.description,
        dependencies: item.dependencies || [],
        devDependencies: item.devDependencies || [],
        registryDependencies: item.registryDependencies || [],
        files: processedFiles,
        categories: item.categories || [],
        meta: item.meta || {},
      }

      // Write individual JSON file for this template
      const jsonPath = path.join(outputDir, `${item.name}.json`)
      await fs.writeFile(jsonPath, JSON.stringify(templateJson, null, 2))

      console.log(`‚úÖ Created ${jsonPath}`)
    } catch (error) {
      console.error(`‚ùå Error processing template ${item.name}:`, error)
    }
  }

  // Also write a master registry.json file
  const registryJsonPath = path.join(outputDir, "registry.json")
  await fs.writeFile(
    registryJsonPath,
    JSON.stringify(validatedRegistry, null, 2)
  )

  console.log(`‚úÖ Created master registry at ${registryJsonPath}`)
}

async function buildTemplatesIndex() {
  // Create a simplified templates index for listing
  const templatesIndex = templates.map((template) => ({
    name: template.name,
    description: template.description,
    categories: template.categories,
    type: template.type,
  }))

  const indexPath = path.join(process.cwd(), "__registry__/templates.json")
  rimraf.sync(indexPath)
  await fs.writeFile(indexPath, JSON.stringify(templatesIndex, null, 2))

  console.log(`‚úÖ Created templates index at ${indexPath}`)
}

// Main execution
async function main() {
  try {
    const styles = Array.from(STYLES)
    console.log(`üé® Found ${styles.length} styles: ${styles.map((s) => s.name).join(", ")}`)

    // Build unified multi-style index
    console.log("\nüóÇÔ∏è Building unified multi-style __registry__/index.tsx...")
    await buildRegistryIndex(styles)

    // Build JSON files for each style
    for (const style of styles) {
      console.log(`\nüì¶ Processing style: ${style.name}`)
      console.log(`üíÖ Building template JSON files for ${style.name}...`)
      await buildTemplateJsonFiles(style.name)
    }

    // Build templates index
    console.log("\nüóÇÔ∏è Building __registry__/templates.json...")
    await buildTemplatesIndex()

    console.log("\n‚úÖ Build complete!")
  } catch (error) {
    console.error("\n‚ùå Build failed:", error)
    process.exit(1)
  }
}

// Run the build
main()